====== getting started with cmake ======
[[http://www.cmake.org|CMake]] is an opensource, cross-platform build system used by many opensource projects including [[http://www.kde.org|KDE]], [[http://opencv.willowgarage.com|OpenCV]], [[http://www.miktex.org|MiKTeX]] or [[http://www.blender.org|Blender 3D]]. It works on Linux, Windows, Mac OS X and can generate native build environments.

Finding simple examples to get started is always difficult. I hope this post helps you to get started with CMake and the Boost unit testing framework. This page will go more into detail as soon as I have some time. :-)

===== Project "geolib" =====
Imagine your are working on a project with GPS data and you are told to write //and test// a library, let's call it //geolib//, to calculate the distance between two positions on earth (also called great-circle distance or orthodromic distance). Points on earth are given in latitude (\phi) and longitude (\lambda) and for the distance calculation one can use the haversine formula:

{{ :blog:haversin1.png |}}

Where //haversin// is:

{{ :blog:haversin2.png |}}

Applying the inverse haversine gives the distance:

{{ :blog:haversin3.png |}}

with //h// = haversin(d/R).

==== Files ====
All files in this post can be downloaded here: 
  * {{:blog:cmake_example.zip|}}. 

The structure of the final project is:

<code>
philipp@banana:~/git/cmake$ tree src
src/
|-- CMakeLists.txt
|-- geolib
|   |-- geolib.cc
|   |-- geolib.h
|   `-- test.cc
`-- main.cc

1 directory, 5 files
</code>

==== Implementation ====

You start by implementing the library. The header file //geolib.h// is using [[http://www.stack.nl/~dimitri/doxygen/|Doxygen]] annotations to document the code. Doxygen is not introduced here, but it is strongly advised to document your work (because someone wants to //use// and //understand// it aswell): 

<code C++>
#ifndef _geolib_h
#define _geolib_h
#include <math.h>

/**
* @author philipp
* @date 2010
*/
namespace geolib {
	
	const double DEG2RAD = M_PI / 180.0;
	const double RAD2DEG = 180.0 / M_PI;
	const double EARTH_RADIUS = 6371.01;
	
	/**
	 * @brief great-circle distance (shortest distance between two points on earth)
	 * @param[in] latitude point 1
	 * @param[in] longitude point 1
	 * @param[in] latitude point 2
	 * @param[in] longitude point 2
	 * @return great-circle distance
	 */
	double great_circle_distance(double lat1, double long1, double lat2, double long2);

}

#endif
</code>

The corresponding source file in //geolib.cc// implements the haversine formula given in the projects description:

<code C++>
#include "geolib.h"

namespace geolib {

	double great_circle_distance(double lat1, double long1, double lat2, double long2) {
		lat1 *= DEG2RAD;
		long1 *= DEG2RAD;
		lat2 *= DEG2RAD;
		long2 *= DEG2RAD;

		double deltaLat = lat1-lat2;
		double deltaLong = long1-long2;
		double a = pow(sin(deltaLat/2.0),2.0) + cos(lat1) * cos(lat2) * pow(sin(deltaLong/2.0),2.0);
		double c = 2 * asin(sqrt(a));

		return EARTH_RADIUS * c;
	}

}
</code>

==== Tests ====
Software has bugs. So tests are important in software development to ensure that components are working correctly. They are a sort of living documentation and should reduce defects and failures, especially when refactoring software. If you are used to JUnit you will find the Boost unit testing framework for C++ pleasing. [[http://www.boost.org|Boost]] is a great library that adds enormous extra power to C++.

The Boost testing framework is a set of macros to validate expressions, where each macro belongs to one of the three test levels:
  * **WARN** logs a warning if the test fails
  * **CHECK** continues the test on failure
  * **REQUIRE** stops the test on failure

The best introduction I found so far is [[http://www.ibm.com/developerworks/aix/library/au-ctools1_boost/|IBM developerWorks: Get to know the Boost unit test framework]]. A list of available macros is given by the [[http://www.boost.org/doc/libs/1_45_0/libs/test/doc/html/utf/testing-tools/reference.html|Boost documentation on testing tools]].

Back to our project. //test.cc// shows how to test the great-circle distance of the //geolib// with the Boost unit testing framework. As test data I use the airport example from the [[http://en.wikipedia.org/wiki/Great-circle_distance|Wikipedia Page on Great-circle distance]]:

<code C++>
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE "GeoLib Tests"
#include <boost/test/unit_test.hpp>
#include "geolib.h"

BOOST_AUTO_TEST_CASE(gcircle_test) {

	double expected = 2886.448973436;

	double bna_lat = 36.12;
	double bna_long = -86.67;
	double lax_lat = 33.94;
	double lax_long = -118.40;

	double actual = geolib::great_circle_distance(bna_lat, bna_long, lax_lat, lax_long);

	BOOST_CHECK_CLOSE(expected, actual, 1e-5);

}
</code>

==== CMakeLists.txt (Putting it all together) ====
cmake searches for a file called CMakeLists.txt in a given folder to build the Makefiles from. The //CMakeLists.txt// for our project is:

<code>
CMAKE_MINIMUM_REQUIRED( VERSION 2.6 )
PROJECT(HELLOWORLD_PROJECT)
INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/geolib")
ADD_LIBRARY(geolib geolib/geolib.cc geolib/geolib.h)
ADD_EXECUTABLE(helloworld main.cc)
TARGET_LINK_LIBRARIES(helloworld geolib)

# Tests
FIND_PACKAGE( Boost REQUIRED COMPONENTS unit_test_framework)
INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
ADD_EXECUTABLE(test_geolib geolib/test.cc)
TARGET_LINK_LIBRARIES(test_geolib ${Boost_LIBRARIES} geolib)
</code>

Building the project can be done by an out of source build:

<code>
philipp@banana:~/git/cmake$ mkdir build && cd build
philipp@banana:~/git/cmake/build$ cmake ../src/
philipp@banana:~/git/cmake/build$ make
</code>
Running the executable //helloworld// calculates the distance from Berlin to Munich (in km):
<code>
philipp@banana:~/git/cmake/build$ ./helloworld 
Distance is 508.978.
</code>

Running the test returns no errors:
<code>
philipp@banana:~/git/cmake/build$ ./test_geolib
Running 1 test case...

*** No errors detected
</code>

===== Appendix =====

==== Download ====
  *  Project: {{:blog:cmake_example.zip|}}

==== CMake on Windows ====
Download the installer from the [[http://www.cmake.org/cmake/resources/software.html|Resources Page]] at http://www.cmake.org (called //cmake-2.8.3-win32-x86.exe// at time of writing). This will install cmake, ccmake and the cmake-gui.

Make sure to select //"Add CMake to the system PATH for all users"// during setup.

==== CMake on Linux ====
CMake should be available from a distributions repository or can be downloaded as an installer from the [[http://www.cmake.org/cmake/resources/software.html|Resources Page]] at http://www.cmake.org (called //cmake-2.8.3-Linux-i386.sh// at time of writing). Installing the generic Linux binaries is done by typing:
<code Bash>
sudo sh cmake-2.8.3-Linux-i386.sh --prefix=/usr/local 
</code>
In Debian or Ubuntu cmake can be installed with apt:
<code Bash>
sudo apt-get install cmake cmake-gui
</code>
==== CMake Snippets ====
=== Using the GNU Scientific Library ===
If you want to use the [[http://www.gnu.org/software/gsl|GSL (GNU Scientific Library)]] link the following libraries:

<code>
find_library(GSL gsl)
find_library(GSL_CBLAS gslcblas)
target_link_libraries(some_name ${GSL} ${GSL_CBLAS})
</code>

{{tag>cmake tutorial boost}}


~~DISCUSSION~~
